Linter.jl
=================

Find and print errors and warnings

**Note:**

This first draft is generated by
- Pablo's notes on linter priorities
- Information from phyton linter
- Some cp information from modeling_language.md and model_speification.md

Sections
--------

A dolo model consists of the following parts and checked by the following function in linter



```
check_model_sections(filename)
```

<!-- Which model sections are optional? So we can check each and return errors and warnings
Also, we could define the loop for all functions (check_symbols, check_equations etc in such a way that if there is a major error,  "symbols section is missing" for instance, other check functions are not run and only the major error is returned)
  -->

- (model) name

- model type

- symbols: all symbols used in the model must be defined

- definitions:

- equations: contains the list of equations

- calibration: provides numeric values for the symbols

- domain:

- exogenous:  a covariances or markov\_chain section where exogenous shocks are defined

- options: -  contains additional information

### Symbols

This section is introduced by the symbols keyword. All symbols appearing
in the model must be defined there.

Symbols are sorted by type as in the following example:

``` {.sourceCode .yaml}
symbols:
  variables: [a, b]
  shocks: [e]
  parameters: [rho]
```

Note that each type of symbol is associated with a symbol list (as [a, b]).

> **note**
>
> A common mistake consists in forgetting the commas, and using spaces
> only. This doesn't work since two symbols are recognized as one.

```
check_symbols(filename)
```
function in linter checks for

- Categories
	- missing symbols types (error)
	- non-existing symbols types (warning)

The expected types depend on the model that is being written.
  > **note**
  >
  > Global models require the definition of the parameters, and to provide
  > a list of states and controls. Mixed states model also require
  > markov\_states that follow a discrete markov chain, while continuous
  > states model need to identify the i.i.d shocks that hit the model. If
  > the corresponding equations are given (see next subsection) optional
  > symbols can also be defined. Among them: values, expectations.

  ```
  required_symbol_types = ["states", "controls", "exogenous", "parameters"]
  optional_symbol_types = [ "values", "rewards", "expectations"]
  ```
- Identifiers
  - each symbol should be a string
  - a valid identifier

Symbols must be valid Julia identifiers (alphanumeric not beginning
with a number) and are case sensitive. Greek letters (save for lambda
which is a keyword) are recognized. Subscripts and superscripts can be
denoted by \_ and \_\_ respectively. For instance beta\_i\_1\_\_d will
be printed nicely as $beta_{i,1}^d$.

<< check_symbol_validity(sym) >>

- No repetition of symbols

### Auxiliary variables / Definitions

In order to reduce the number of variables, it is useful to define
auxiliary variables $y_t$ using a function $a$ such that:

$$y_t = a(m_t, s_t, x_t)$$

These variables are defined in a special `definitions` block, outside of `equations`.
When auxiliary variables appear in an equation they are automatically substituted by
the corresponding expression in $m_t$,$s_t$ and $x_t$.


> **note**
>
> In the RBC model, three auxiliary variables are defined
> $y_t, c_t, r_{k,t}$ and $w_t$. They are a closed form function of
> $a_t, k_t, i_t, n_t$. Defining these variables speeds up computation
> since they are don't need to be solved for or interpolated.

```check_definitions(filename) ``` function in linter checks for

keys (auxilary variables) which must

- be a valid identifier
- not defined elsewhere


### Equations

The various equations understood by Dolo are described below:

<!-- would be cool to know how to make comments ;-) -->


```check_equations(filename) ``` function in linter checks for

- Types
	- missing equation types (error)
	- non-existing symbols types (warning)

```
  required_equation_types = ["transition"]
  optional_equation_types = ["arbitrage", "value", "felicity", "expectation"]
```

- Numbers of equations
```
	number of transition equations --> number of states
	number of arbitrage equations --> number of controls
```



### Calibration

The role of the calibration section consists in providing values for the
parameters and the variables. The calibration of all parameters
appearing in the equation is of course strictly necessary while the
calibration of other types of variables is useful to define the
steady-state or an initial guess of the steady-state.

The calibrated values are also substituted in other sections, including
the shocks and options section. This is particularly useful to make the
covariance matrix depend on model parameters, or to adapt the
state-space to the model's calibration.

The calibration is given by an AbstractDict dictionary mapping symbols to
define with values. The values can be either a scalar or an expression.
All symbols are treated in the same way, and values can depend upon each
other as long as there is a way to resolve them recursively.

In particular, it is possible to define a parameter in order to target a
special value of an endogenous variable at the steady-state. This is
done in the RBC example where steady-state labour is targeted with
`n: 0.33` and the parameter `phi` calibrated so that the optimal labour
supply equation holds at the steady-state (`chi: w/c^sigma/n^eta`).

All symbols that are defined in the symbols section but do not appear in
the calibration section are initialized with the value nan without
issuing any warning.

> **note**
>
> No clear policy has been established yet about how to deal with
> undeclared symbols in the calibration section. Avoid them.

***
Calibration
- key repeated --> error
- key not in symbols --> warning
- symbol not in calib --> warning
***


```check_calibration(fn) ```



```check_domain(fn) ```




```check_exogenous(fn) ```



```No check function ```



### Domain
The domain section defines lower and upper bounds for the exogenous and endogenous states. For example, in the RBC model, we write:
``` {.sourceCode .yaml}
domain:
  z: [-2*sig_z/(1-rho^2)^0.5,  2*sig_z/(1-rho^2)^0.5]
  k: [ k*0.5, k*1.5]
```
The part for `z` sets the bounds for the productivity process to be two times its asymptotic standard deviation.

The boundaries for capital are a 50% bracket around its steady-state level.

***
Domain (optional)
- keys must contain all states
- values should match [exp, expr]
***


### Exogenous

Exogenous shock processes are specified in the section `exogenous` . Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Dolo also allows for specific types of Markov Chains such as Poisson Processes, Aging Processes, and Death Processes.

Here are examples of how to define different processes. Note the use of yaml tags.
Normal Shock: It has mean zero and variance `Sigma`.
```{.sourceCode .yaml}
exogenous:!Normal
   Sigma: [[0.016^2]]
```
VAR1: `rho` is the persistence (only one allowed for now). `Sigma` is the covariance matrix. (Note: if a scalar `sigma` is given, it will be converted to `[[sigma]]` to indicate that it is the variance (not covariance) of the process).  
```{.sourceCode .yaml}
exogenous:!VAR1
    rho: 0.9
    sigma: [[0.01, 0.001],
             [0.001, 0.02]]
    N: 3
```
Markov Chain:
```{.sourceCode .yaml}
exogenous: !MarkovChain
  values: [[-0.01],[0.01]]
  transitions: [[0.9, 0.1], [0.1, 0.9]]
```
Poisson Process: `K` is the number of nodes and `mu` is the probability of a new arrival.
```{.sourceCode .yaml}
exogenous: !PoissonProcess
  mu: 0.05
  K: 10
```

Aging Process: `mu` is the probability of death and `K` is the maximum age. Note this also encompasses an indicator for death, so in the definition of exogenous variables you will need a variable for age and an indicator for death.

```{.sourceCode .yaml}
exogenous:!AgingProcess
  mu: 0.02
  K: 8
```

Death Process: `mu` is the probability of dying.
```{.sourceCode .yaml}
exogenous:!DeathProcess
  mu:0.02
```
We can also specify more than one process. For instance if we want to combine a VAR1 and an Aging Process we use the tag `Product` and write:
```{.sourceCode .yaml}
exogenous: !Product
    p1: !VAR1
         rho: 0.75
         Sigma: [[0.015^2]]

         N: 3

    p2: !AgingProcess
        mu: 0.02
        K: 8

```

***
Exogenous (optional)
- type should be known (Normal, VAR1, ...)

***


### Options
The options sections contains extra information needed to solve the model.The
section follows the mini-language convention, with all calibrated values
replaced by scalars and all keywords allowed.

Here we can define the grids and specify their type, Cartesian. We can also specify how many grid points we want for `z` and `k`. Here we choose 5 points for `z` and 50 points for `k`. Note that the grid points are listed in accordance with the declaration order of the variables.
``` {.sourceCode .yaml}
options:
  grid: !Cartesian
        orders: [5, 50]
```
***
Options: No check
***

# Notes

- Need to update the documentation?

(at least on of these is not up to date: modeling_language.md and model_speification.md)

- There is a markdown syntax error on linter branch @ line 137? (maybe just a atom markdown-preview-plus problem)
